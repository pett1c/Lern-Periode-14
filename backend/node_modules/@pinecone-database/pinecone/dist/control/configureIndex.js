"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIndexSpecType = exports.configureIndex = void 0;
const db_control_1 = require("../pinecone-generated-ts-fetch/db_control");
const errors_1 = require("../errors");
const createIndex_1 = require("./createIndex");
const describeIndex_1 = require("./describeIndex");
const configureIndex = (api) => {
    const validator = (options) => {
        if (!options.name) {
            throw new errors_1.PineconeArgumentError('You must pass a non-empty string for `name` to configureIndex.');
        }
        // !options.deletionProtection evaluates to false if options.deletionProtection is undefined, empty string, or
        // not provided
        if (!options.deletionProtection &&
            !options.tags &&
            !options.embed &&
            options.podReplicas === undefined &&
            options.podType === undefined &&
            options.readCapacity === undefined) {
            throw new errors_1.PineconeArgumentError('You must pass at least one configuration option to configureIndex.');
        }
        if (options.readCapacity) {
            (0, createIndex_1.validateReadCapacity)(options.readCapacity);
        }
    };
    return async (options) => {
        validator(options);
        // Only fetch the index description when spec-type-dependent params are present,
        // avoiding an extra network round-trip for common updates (deletionProtection, tags, embed).
        const needsSpecType = options.podReplicas !== undefined ||
            options.podType !== undefined ||
            options.readCapacity !== undefined;
        let specType = 'unknown';
        if (needsSpecType) {
            const indexDescription = await (0, describeIndex_1.describeIndex)(api)(options.name);
            specType = (0, exports.getIndexSpecType)(indexDescription.spec);
        }
        // Validate that spec-specific parameters match the index type
        if (specType === 'pod' && options.readCapacity !== undefined) {
            throw new errors_1.PineconeArgumentError('Cannot configure readCapacity on a pod index; readCapacity is only supported for serverless and BYOC indexes.');
        }
        if ((specType === 'serverless' || specType === 'byoc') &&
            (options.podReplicas !== undefined || options.podType !== undefined)) {
            throw new errors_1.PineconeArgumentError(`Cannot configure podReplicas or podType on a ${specType} index; these parameters are only supported for pod indexes.`);
        }
        // Guard against silently discarding spec params when the index type could not be determined.
        if (needsSpecType && specType === 'unknown') {
            throw new errors_1.PineconeArgumentError('Could not determine the index spec type. Verify the index exists and try again.');
        }
        const spec = buildConfigureSpec(options, specType);
        const request = {
            deletionProtection: options.deletionProtection,
            tags: options.tags,
            embed: options.embed,
            spec,
        };
        return await api.configureIndex({
            xPineconeApiVersion: db_control_1.X_PINECONE_API_VERSION,
            indexName: options.name,
            configureIndexRequest: request,
        });
    };
};
exports.configureIndex = configureIndex;
/**
 * Determines the spec type of an index by which spec key has a defined value.
 *
 * @param spec - The IndexModelSpec from describeIndex (may have multiple keys, only one defined)
 * @returns The spec type: 'pod', 'serverless', or 'byoc'
 * @internal Exported for testing
 */
const getIndexSpecType = (spec) => {
    if (spec == null || typeof spec !== 'object') {
        return 'unknown';
    }
    // Classify by which key has a defined object value (order is arbitrary but deterministic).
    // Use 'in' to narrow the union before reading the property.
    if ('serverless' in spec &&
        spec.serverless != null &&
        typeof spec.serverless === 'object') {
        return 'serverless';
    }
    if ('byoc' in spec && spec.byoc != null && typeof spec.byoc === 'object') {
        return 'byoc';
    }
    if ('pod' in spec && spec.pod != null && typeof spec.pod === 'object') {
        return 'pod';
    }
    return 'unknown';
};
exports.getIndexSpecType = getIndexSpecType;
const buildConfigureSpec = (options, specType) => {
    const hasPod = options.podReplicas !== undefined || options.podType !== undefined;
    const hasReadCapacity = options.readCapacity !== undefined;
    if (hasPod && hasReadCapacity) {
        throw new errors_1.PineconeArgumentError('Cannot configure both pod (podReplicas/podType) and readCapacity in the same request; these parameters are mutually exclusive.');
    }
    // Handle pod configuration
    if (hasPod && specType === 'pod') {
        return {
            pod: {
                replicas: options.podReplicas,
                podType: options.podType,
            },
        };
    }
    // Handle serverless configuration
    if (hasReadCapacity && specType === 'serverless') {
        return {
            serverless: {
                readCapacity: (0, createIndex_1.toApiReadCapacity)(options.readCapacity),
            },
        };
    }
    // Handle BYOC configuration
    if (hasReadCapacity && specType === 'byoc') {
        return {
            byoc: {
                readCapacity: (0, createIndex_1.toApiReadCapacity)(options.readCapacity),
            },
        };
    }
    return undefined;
};
//# sourceMappingURL=configureIndex.js.map